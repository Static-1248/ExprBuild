# 项目信息与状态
**版本**：0.0.0

## 项目概览
1. **项目目标**：

	用户通过编写类似 `` const c = expr`${a}^2 + ${b}^2` `` 的代码，生成 Desmos 兼容的数学表达式，最终制作并导出 Desmos 图表。

	**ExprBuild 是：**
	- In short: 创作 Desmos 图表的 JS 框架。JS framework for creating Desmos graphs.
	- In long: 一个用于生成 Desmos 图表的 JS/TS 库，提供表达式的创建、组织，和 Desmos 图表生成等功能。同时提供开发服务器，支持实时预览和导出 Desmos 图表；以及 VSCode 插件，提供代码提示和语法高亮等功能。
	- ExprBuild是面向Desmos的，设计导向是以代码的形式在用户和Desmos之间搭建桥梁。所以绝大部分内容都是围绕着Desmos功能展开的，而不是一个独立的数学表达式库。

	**ExprBuild 产品将包括：**
	- **JS/TS库**：核心库，提供表达式的创建、组织，和Desmos图表生成等功能。
	- **开发服务器**：提供本地开发环境，支持实时预览和导出Desmos图表。目前暂定依托于Vite实现开发体验，因而我们需要制作一个Vite插件。
	- **VSCode插件**：提供代码提示和DSL语法高亮等功能。
		> 本工程只包括vscode插件，但整个项目依然作为一个整体开发，所以我们在不同工程之间同步这份关于整个项目的文档。

2. **开发背景**: 
	- 开发者熟悉js/ts和前端开发，但对vscode插件开发和DSL解析器开发不熟悉。
	- 开发者将使用Copilot等AI工具辅助开发，所以需要维护本文档以便AI工具理解项目背景、需求、进展等。
	- **关于本文档**：
		- 本文档将作为AI执行任务时的兜底参考，每一次AI任务中开发者都会附上这篇文档作为参考。
		- 如果AI需要编辑此文档，请务必保持此文档的底线功能，即任何一个其他AI在执行任务前都可以通过阅读此文档了解项目的所有必要信息，包括背景、需求、进展等。
		- 同时只向文档里存放AI理解项目所需的必要信息。举例，“技术细节”一节可能存放一些未被代码实现的技术细节，如果相关代码已经实现，那么这些技术细节应该被移除，因为这些信息已经在代码里体现了。
	- **AI注意事项**：（！！切记！！）
		- 我们在Windows环境下开发，请AI注意使用正确的PowerShell命令。
			- 例如，Powershell不支持`&&`，请合理使用`;`。
		- 我们使用pnpm作为包管理器，请AI注意使用正确的命令。
		- 如果AI打算引入新的工具或技术，请先征求开发者意见。因为AI不知道开发者是否熟悉这个工具或技术，是否需要向开发者介绍，是否需要开发者参与讨论工具链的选择等。
		- 我通过Roo Code插件让你们进行工作，但是Roo Code提供的上下文可能有点问题。如果看到历史记录里“用户”或者“系统”进行了操作，这实际上是**你**进行的历史操作。如果看到历史记录里存在用户与其他AI的对话，这实际上是我与**你**对话的记录。对话记录里只存在我、系统与你，不存在其他AI。
		- 请使用中文进行思考。

		- 由于Roo Code限制你一次只能使用一步工具，所以当你决定接下来需要进行多步操作后，请先在对话中讲述你的分步操作计划，然后参照你的计划逐步执行。
			- 如果你已经在参照之前已讲述的分步计划，正在执行其中一步，那么这一轮不必将计划再复述一遍，直接按照计划进行该步操作即可。
			- 如果你需要修改计划，请在对话中重新讲述新的计划，然后重新开始逐步执行。
		
		- 请务必不要轻易attempt completion，不要声明任务已经完成。attempt completion前务必询问开发者意见，开发者同意后才能attempt completion。

3. **技术细节**：

	> 在这里存放：代码尚未实现，所以无法在代码里体现，必须先在这里记一下的技术细节；其他必须在代码之外补充的技术细节。
	
	- **开发服务器架构**：
		- 基于Vite插件实现，通过虚拟模块导入核心库生成的Desmos state
		- 热更新机制：监听表达式文件变化 → 重新生成state → 通过WebSocket推送更新

	- **DSL解析流程**：
		1. 词法分析：将模板字符串拆分为token流
		2. 语法分析：生成AST（抽象语法树）
		3. 语义分析：检查变量引用有效性
		4. 代码生成：输出Desmos兼容的LaTeX表达式

	- **依赖追踪实现**：
		- 关键概念：
			- explName: explicit表达式在Desmos中的唯一标识符（如`a=3`中的'a'）
			- JS变量名与explName解耦，允许重命名JS变量而不影响Desmos表达式
		- 每个表达式对象维护：
			- deps: 直接依赖的表达式对象集合（运行时引用）
			- explNameDeps: 依赖的explName集合（类型系统追踪）
		- 类型系统解析实现：
			- 基于模板字面量类型（Template Literal Types）解析DSL
			- 构建explName依赖图，检测循环依赖和未定义引用
			- 通过条件类型判断表达式类型（Equation/Expression/Inequality）
		- 冲突检测：
			- 编译时确保所有explName全局唯一
			- 运行时注册表维护explName与表达式对象的映射
    - Desmos 通过 JS API 动态加载，关键功能是Desmos计算器状态(state)对象的读写，示例代码：
        ```html
        <div id="calculator"></div>
        <script src="https://www.desmos.com/api/v1.8.0/calculator.js"></script>
        <script>
          const calculator = Desmos.Calculator(document.getElementById('calculator'));
          calculator.setState(生成的State对象);
        </script>
        ```
	- **ExprBuild DSL**：
		- 用户创建表达式的唯一方式是使用ExprBuild的模板字符串，如 `` const c = expr`${a}^2 + ${b}^2` ``。模板字符串内部为ExprBuild DSL.
			> 备注：这样子设计是因为JS不支持重载运算符，所以很难通过JS语法直接创建表达式对象...... 不过这也导致我们需要提供DSL开发支持（如vscode插件），否则用户的开发体验仍然会约等于0（）\
			> 实际上引入DSL不会导致用户的开发工程脱离原生，因为本质上这些DSL是运行时才会被解析的模板字符串（函数调用）。但是显然还是要为这里的DSL提供DevEx支持。
		- 模板字符串支持传入变量（且可以使用自定义的逻辑来处理这些变量），这允许了用户创建依赖于其他表达式的表达式。不过麻烦的地方在于输入一个变量名时必须输入“${变量名}”，略为繁琐，除非我们在vscode插件里提供代码提示/代码补全功能。
		- DSL表达式的最终类型（比如它是表达式还是函数还是无效表达式等）需要体现为TS类型，所以我们需要写亿点类型体操来推断DSL表达式的类型了（泪
		- DSL字符串不会直接作为Desmos的latex表达式，语法也不直接等效于Desmos+latex语法；ExprBuild DSL会被首先解析为ExprBuild对象，导出时再转换为Desmos的latex表达式
		- 更多细节请参考[DSL规范文档](docs/dsl-spec.md)。但注意这个文档尚未完工，仅作参考。

    - **ExprBuild 表达式依赖体系**:

	    ExprBuild 的表达式对象分为两种：显式表达式（explicit）和内联表达式（inline）。

        - **explicit 表达式 (使用`expl`定义):**：
            - **定义**：生成独立的变量定义式（如 `a=3`），会出现在 Desmos 表达式列表中，成为Desmos图形计算器的有效变量。
            - **示例**：``const a = expl`a = 3`;`` 定义了一个变量 `a`。
            - **作用**：在Desmos图形计算器里，这些变量一边完成被其他表达式引用。
        
        - **inline 表达式 (使用`expr`定义):**：
            - **定义**：生成内联表达式，会被替换为其符号内容，不会单独出现在表达式列表中。
            - **示例**：``const c = expr`${a}^2 + ${b}^2`;`` 生成了一个依赖于 `a` 和 `b` 的内联表达式。
            - **作用**：通常作为WIP/中间体等，在图象构建时这些表达式会将其内容代入所有引用它的地方，自身不会单独出现在表达式列表中。

        - **示例**
           
		    ```javascript
            const a = expl`a = 3`;
            const b = expl`b = 4`;
            const c = expr`${a}^2 + ${b}^2`;
	        ```

	    - **依赖管理**:
			
			每个 ExprBuild 表达式都会存储相关依赖信息。
			
			- 每个表达式对象保存其依赖的表达式对象的引用；
			- 每个表达式的内容在创建后无法修改，这意味着表达式的依赖关系在创建时就已经确定。
				> 备注：这样设计可能会导致自由度不够高等问题，但不采用这一点的话下面的"使用类型系统跟踪所有explicit依赖的变量名"就无法实现，因为“动态”就必然意味着“未知”。后面再考虑是否需要支持动态依赖关系。 
			- 每个表达式内记录其依赖的explicit表达式的变量名。同时如果使用TS，也会在类型系统里跟踪所有explicit依赖的变量名。
			- 在结构不可变的前提下，不会出现循环依赖的情况。
	        > 备注: 相关技术细节待补充。

### 项目进度

#### 历史记录
- 无

#### 当前工作

1. **VSCode插件基础架构**：
	- 已完成DSL语法高亮实现（syntaxes/exprbuild.tmLanguage.json）
	- 语言服务器框架初始化（packages/vscode/src/extension.ts）

2. **核心库进展**：
	- 实现基础表达式注册表（packages/core/src/index.ts）
	- 完成expl/expr基类定义
	- 建立monorepo依赖关系（pnpm workspace配置）

3. **开发服务器原型**：
	- 搭建Vite插件基础框架（packages/dev/src/index.ts）
	- 实现Desmos Calculator基础渲染

#### 下一步计划

##### 核心优先级（v0.1.0）
- [ ] 类型系统开发
	- 模板字符串类型解析（Template Literal Types）
	- explName依赖图类型推导
	- 表达式类型校验（Equation/Expression/Inequality）

- [ ] 依赖追踪系统
	- 实现explName全局唯一性校验
	- 开发全量状态生成机制

##### 次级任务（v0.1.1）
- [ ] 开发服务器增强
	- 虚拟模块导入Desmos state
	- 基础HMR支持

- [ ] 测试体系搭建
	- 配置Vitest测试环境
	- 核心类型校验测试用例

##### 长期规划
- [ ] VSCode插件智能提示
- [ ] 多图表管理功能
- [ ] 生产环境构建优化

## 版本历史

> 本节记录项目的版本历史，包括版本号、更新日期、主要更新内容等。
> 注意，只有足够大的、完整的功能更新才会被记录为一次版本更新。（事实上现阶段完全不需要记录版本历史）